<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arduino Camera Test (CAFE Binary)</title>
  <!-- Arduino 전용: CAFE 바이너리 카메라 테스트 -->
  <script src="./integratedBleLib_Camera.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 980px; margin: 0 auto; padding: 16px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; background: #1976d2; color: #fff; font-weight: 700; }
    button.secondary { background: #455a64; }
    button.danger { background: #c62828; }
    button:disabled { background: #cfcfcf; cursor: not-allowed; }
    input, select { padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; }
    #log { width: 100%; height: 220px; border: 1px solid #ddd; border-radius: 6px; padding: 10px; background: #fafafa; overflow: auto; white-space: pre-wrap; }
    #cameraView { width: 320px; height: 240px; border: 1px solid #ddd; background: #f0f0f0; object-fit: contain; }
    .hint { color: #666; font-size: 13px; line-height: 1.4; }
    .badge { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #c62828; }
    .badge.on { background: #2e7d32; }
    code { background: #f5f5f5; padding: 2px 6px; border-radius: 4px; }
    .kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 12px; }
    .kv div { font-size: 13px; }
  </style>
</head>
<body>
  <h2>Arduino Camera Test (CAFE Binary)</h2>
  <div class="hint">
    - 라이브러리: <code>arduino/test/integratedBleLib_Camera.js</code><br />
    - 서비스: <code>CAMERA_SERVICE</code> / TX:<code>CAMERA_TX_CHAR_UUID</code> / RX:<code>CAMERA_RX_CHAR_UUID</code><br />
    - Web Bluetooth는 <b>HTTPS 또는 localhost</b>에서만 동작합니다.
  </div>

  <div class="row" style="margin-top: 12px;">
    <span class="badge" id="statusDot"></span>
    <span id="statusText">연결 안됨</span>
    <button id="connectBtn">연결</button>
    <button id="disconnectBtn" class="secondary" disabled>해제</button>
  </div>

  <div class="row" style="margin-top: 10px;">
    <label for="namePrefixInput"><b>namePrefix</b></label>
    <input id="namePrefixInput" type="text" value="DCB" style="width: 140px;" />
    <label style="display:flex; align-items:center; gap:6px;">
      <input id="acceptAllChk" type="checkbox" />
      모든 BLE 장치 표시(디버그)
    </label>
    <span class="hint">목록이 비면 디버그 체크 후 전체 장치가 뜨는지 먼저 확인하세요.</span>
  </div>

  <hr />

  <div class="row">
    <img id="cameraView" alt="camera view" />
    <div style="flex: 1; min-width: 320px;">
      <div class="row" style="margin-bottom: 8px;">
        <label for="intervalInput"><b>Stream interval(ms)</b></label>
        <input id="intervalInput" type="number" min="50" max="2000" value="200" style="width: 90px;" />
        <button id="applyCamBtn" class="secondary" disabled>설정 적용</button>
        <label style="display:flex; align-items:center; gap:6px; margin-left:8px;">
          <input id="verboseLogChk" type="checkbox" checked />
          상세 로그(프레임/청크)
        </label>
        <label style="display:flex; align-items:center; gap:6px; margin-left:8px;">
          <input id="strictModeChk" type="checkbox" checked />
          Strict(불완전 프레임 폐기)
        </label>
      </div>

      <div class="row">
        <button id="snapBtn" disabled>사진 촬영</button>
        <button id="saveBtn" class="secondary" disabled>저장</button>
        <button id="startBtn" disabled>스트리밍 시작</button>
        <button id="stopBtn" class="danger" disabled>스트리밍 중지</button>
      </div>

      <div class="hint" style="margin-top: 8px;">
        느리면: interval 200~400 권장 (프레임/품질 설정은 현재 JS에서 미사용)
      </div>
    </div>
  </div>

  <h3 style="margin-top: 14px;">Stats</h3>
  <div class="kv">
    <div><b>frames</b></div><div id="statFrames">0</div>
    <div><b>last bytes</b></div><div id="statBytes">-</div>
    <div><b>fps(최근)</b></div><div id="statFps">-</div>
  </div>

  <h3 style="margin-top: 14px;">Log</h3>
  <div id="log"></div>

  <script>
    const $ = (id) => document.getElementById(id);
    const logEl = $('log');
    const statusDot = $('statusDot');
    const statusText = $('statusText');
    const connectBtn = $('connectBtn');
    const disconnectBtn = $('disconnectBtn');
    const snapBtn = $('snapBtn');
    const saveBtn = $('saveBtn');
    const startBtn = $('startBtn');
    const stopBtn = $('stopBtn');
    const intervalInput = $('intervalInput');
    const verboseLogChk = $('verboseLogChk');
    const strictModeChk = $('strictModeChk');
    const applyCamBtn = $('applyCamBtn');
    const cameraView = $('cameraView');
    const namePrefixInput = $('namePrefixInput');
    const acceptAllChk = $('acceptAllChk');

    const statFrames = $('statFrames');
    const statBytes = $('statBytes');
    const statFps = $('statFps');
    let lastApplied = null; // applied settings snapshot (supported keys only)
    let camCaps = null;     // { frameSize, quality, interval, strictMode, debugLog }

    function getDesiredSettings() {
      const interval = Math.max(50, Math.min(2000, parseInt(intervalInput.value, 10) || 200));
      intervalInput.value = String(interval);
      return { interval };
    }

    async function applySettingsIfNeeded(force = false) {
      ensureCamera();
      const desired = getDesiredSettings();
      // Compare only supported settings to avoid "applied" lies.
      const same = !!lastApplied && !!camCaps &&
        (!camCaps.interval || lastApplied.interval === desired.interval);

      if (!force && same) {
        log('설정 변경 없음: 적용 생략');
        return;
      }

      const applied = {};

      // Interval exists in both variants, but the command format can differ internally.
      // Prefer the library method if present.
      log(`CAM:INTERVAL:${desired.interval} 전송`);
      if (typeof camera.setStreamInterval === 'function') {
        await camera.setStreamInterval(desired.interval);
        applied.interval = desired.interval;
      } else if (typeof camera.sendCommand === 'function') {
        // MicroPython-compatible command format (space) also accepted by current firmware.
        await camera.sendCommand(`CAM:INTERVAL ${desired.interval}`);
        applied.interval = desired.interval;
      } else {
        throw new Error('camera.setStreamInterval/sendCommand 둘 다 없음');
      }

      lastApplied = applied;
      const appliedKeys = Object.keys(applied);
      log(appliedKeys.length ? `설정 적용 완료: ${appliedKeys.join(', ')}` : '설정 적용 완료(적용 항목 없음)');
    }

    function log(msg) {
      const ts = new Date().toLocaleTimeString();
      logEl.textContent += `[${ts}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Preflight
    (function preflight() {
      const hasBluetooth = typeof navigator !== 'undefined' && !!navigator.bluetooth;
      const secure = typeof window !== 'undefined' ? !!window.isSecureContext : false;
      log(`환경 체크: secureContext=${secure}, navigator.bluetooth=${hasBluetooth}`);
      if (!secure) log('오류: Web Bluetooth는 HTTPS 또는 localhost에서만 동작합니다.');
      if (!hasBluetooth) log('오류: 이 브라우저는 Web Bluetooth API를 지원하지 않습니다. (Chrome/Edge 권장)');
      if (!secure || !hasBluetooth) {
        connectBtn.disabled = true;
      }
    })();

    const bleManager = BLEManager.getInstance();
    let camera = null;

    let frames = 0;
    const frameTimes = [];
    function updateStats(blob) {
      frames += 1;
      statFrames.textContent = String(frames);
      statBytes.textContent = blob ? String(blob.size) : '-';
      const now = performance.now();
      frameTimes.push(now);
      while (frameTimes.length > 60) frameTimes.shift();
      if (frameTimes.length >= 2) {
        const dt = (frameTimes[frameTimes.length - 1] - frameTimes[0]) / 1000;
        const fps = dt > 0 ? (frameTimes.length - 1) / dt : 0;
        statFps.textContent = fps.toFixed(2);
      }
    }

    function setUiConnected(connected) {
      statusDot.classList.toggle('on', !!connected);
      statusText.textContent = connected ? '연결됨' : '연결 안됨';
      connectBtn.disabled = !!connected;
      disconnectBtn.disabled = !connected;
      snapBtn.disabled = !connected;
      saveBtn.disabled = !connected;
      startBtn.disabled = !connected;
      stopBtn.disabled = !connected;
      applyCamBtn.disabled = !connected;
    }

    function ensureCamera() {
      if (camera) return;
      camera = new Camera();
      camCaps = {
        interval: (typeof camera.setStreamInterval === 'function' || typeof camera.sendCommand === 'function'),
        strictMode: (typeof camera.setStrictMode === 'function'),
        debugLog: (typeof camera.setOnDebugLog === 'function')
      };

      // Backward compatible: MicroPython-style Camera may not expose setOnDebugLog().
      if (typeof camera.setOnDebugLog === 'function') {
        camera.setOnDebugLog((message, data) => {
          if (!verboseLogChk.checked) return;
          // Keep it readable; stringify small objects only
          let extra = '';
          try {
            if (data && typeof data === 'object') {
              extra = ' ' + JSON.stringify(data);
            }
          } catch (_) {}
          log(message + extra);
        });
      }
      camera.setOnImageComplete((blob) => {
        log(`이미지 수신 완료: ${blob.size} bytes`);
        updateStats(blob);
        // Use object URLs safely: revoke the previous one ASAP to avoid memory growth during streaming.
        const url = URL.createObjectURL(blob);
        const prevUrl = cameraView.dataset.lastUrl || '';
        cameraView.onload = () => {
          try { URL.revokeObjectURL(url); } catch (_) {}
        };
        cameraView.src = url;
        cameraView.dataset.lastUrl = url;
        if (prevUrl && prevUrl.startsWith('blob:') && prevUrl !== url) {
          try { URL.revokeObjectURL(prevUrl); } catch (_) {}
        }
      });
      camera.setOnStreamingStateChange((isStreaming) => {
        log(`스트리밍 상태: ${isStreaming ? 'ON' : 'OFF'}`);
      });
      // Backward compatible: some Camera implementations don't expose strict mode.
      if (typeof camera.setStrictMode === 'function') {
        camera.setStrictMode(!!strictModeChk.checked);
      } else {
        // If not supported, disable the toggle to avoid confusing UX.
        strictModeChk.disabled = true;
      }
      log('Camera 객체 초기화 완료');
    }

    strictModeChk.addEventListener('change', () => {
      if (!camera) return;
      if (typeof camera.setStrictMode === 'function') {
        camera.setStrictMode(!!strictModeChk.checked);
        log(`Strict 모드: ${strictModeChk.checked ? 'ON (불완전 프레임 폐기)' : 'OFF (best-effort 표시)'}`);
      } else {
        strictModeChk.disabled = true;
      }
    });

    bleManager.onConnectionChange((connected) => {
      setUiConnected(connected);
      if (connected) ensureCamera();
      if (!connected) {
        camera = null;
        lastApplied = null;
        cameraView.src = '';
        frames = 0;
        frameTimes.length = 0;
        statFrames.textContent = '0';
        statBytes.textContent = '-';
        statFps.textContent = '-';
      }
    });

    if (typeof bleManager.onConnectionFailed === 'function') {
      bleManager.onConnectionFailed((msg) => log(`연결 실패 콜백: ${msg}`));
    }
    if (typeof bleManager.onDisconnected === 'function') {
      bleManager.onDisconnected((info) => log(`연결 해제: ${JSON.stringify(info)}`));
    }

    connectBtn.addEventListener('click', async () => {
      try {
        log('BLE 연결 시도...');
        const acceptAll = !!acceptAllChk.checked;
        const prefix = (namePrefixInput.value || '').trim();
        log(acceptAll ? '디버그 모드: acceptAllDevices=true' : `필터: namePrefix=${prefix || '(기본: DCB/DeepCoB)'}`);
        await bleManager.connect([], { acceptAllDevices: acceptAll, namePrefix: acceptAll ? '' : prefix });
        log('BLE 연결 성공');
      } catch (e) {
        log(`연결 실패: ${e.message || e}`);
      }
    });

    disconnectBtn.addEventListener('click', () => {
      try {
        log('BLE 연결 해제');
        bleManager.disconnect();
      } catch (e) {
        log(`해제 오류: ${e.message || e}`);
      }
    });

    applyCamBtn.addEventListener('click', async () => {
      if (!bleManager.isConnected) return;
      try {
        await applySettingsIfNeeded(true);
      } catch (e) {
        log(`설정 오류: ${e.message || e}`);
      }
    });

    snapBtn.addEventListener('click', async () => {
      if (!bleManager.isConnected) return;
      ensureCamera();
      try {
        log('CAM:SNAP 전송');
        await camera.takeSnapshot();
      } catch (e) {
        log(`SNAP 오류: ${e.message || e}`);
      }
    });

    saveBtn.addEventListener('click', () => {
        if (cameraView.src && cameraView.src.startsWith('blob:')) {
            const a = document.createElement('a');
            a.href = cameraView.src;
            a.download = `capture_${new Date().toISOString().replace(/[:.]/g, '-')}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        } else {
            log('저장할 이미지가 없습니다.');
        }
    });

    startBtn.addEventListener('click', async () => {
      if (!bleManager.isConnected) return;
      ensureCamera();
      try {
        // Apply only if changed (avoid duplicate BLE writes)
        await applySettingsIfNeeded(false);
        log('CAM:STREAM:ON 전송');
        await camera.startStreaming();
      } catch (e) {
        log(`STREAM ON 오류: ${e.message || e}`);
      }
    });

    stopBtn.addEventListener('click', async () => {
      if (!bleManager.isConnected) return;
      if (!camera) return;
      try {
        log('CAM:STREAM:OFF 전송');
        await camera.stopStreaming();
      } catch (e) {
        log(`STREAM OFF 오류: ${e.message || e}`);
      }
    });

    setUiConnected(false);
  </script>
</body>
</html>

